Question

1 Assuming that the following JOS kernel code is correct, what type should variable x have, uintptr_t or physaddr_t?
	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;

mystery_t应为uintptr_t，因为程序是无法绕过mmu的，所以就算是physical address也会被当作virtual address被mmu变成新的physical address

2 What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:
Entry	Base Virtual Address		Points to (logically):
1023	?						Page table for top 4MB of phys memory
1022	?						?
.		?						?
.		?						?
.		?						?
2		0x00800000				?
1		0x00400000				?
0		0x00000000				[see next question]

Entry	Base Virtual Address		Points to (logically):
1023	0xffc00000				Page table for top 4MB of phys memory
1022	0xff800000				?
.		?						?
960		0xf0000000				Page table for kernel base 映射物理地址0开始
959		0xefc00000				Page table for kernal stacktop
956		0xef000000				Page table for UPAGES
.		?						?
.		?						?
2		0x00800000				Page table for third 4MB of phys memory
1		0x00400000				Page table for second 4MB of phys memory
0		0x00000000				[see next question]

3 (From Lecture 3) We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?

通过页目录的权限位来限制user的访问kernel address space，而mmu通过地址翻译会将user address space与kernel address space分开

4 What is the maximum amount of physical memory that this operating system can support? Why?

UPAGES—UVPT是kernel映射到user address space，用来存放pages的，page struct为8byte，管理的物理内存大小是4KB,这段内存大小为4MB
所以总共能管理的物理内存大小为4KB*(4MB/8byte) = 2GB
但是如果只考虑kernel,那么kernel不需要访问映射的内存，而是直接访问pages，所以可以直接开8M的空间（也就是根据一级页表1024*1024*4K）映射4G内存，而只random的给user address space映射其中的4M

5 How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?

由前一题目两个讨论
1、pages占4M，一级页目录占4K，二级页目录占512*4K=2M（2GB的物理内存只需要512个二级页表就能映射完）,总共为4M+2M+4K=6M+4K
但是实际上lab中按照We might not have 2^32 - KERNBASE bytes of physical memory, but we just set up the mapping anyway.来看的话，二级页表的确被用完了，也就是1024个二级页表，总共为4M+4M+4K=8M+4K
2、pages占8M，一级页目录占4K，二级页目录占1024*4K=4M（4GB的物理内存需要1024个二级页表能映射完）,总共为8M+4M+4K=12M+4K

6 Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

line67:jmp *%eax
在low EIP运行时，虽然已经把0—4M映射到了KERNBASE—KERNBASE+4M，但是0—4M依然可用，0开始的一个page和kernal base的一个page指向了同一段physical address
但是在把EIP跳转到KERNBASE之上之前，还没开始执行在KRENBASE之上的C代码，我们需要执行C代码，所以必须跳转EIP
